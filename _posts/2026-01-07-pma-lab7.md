---
layout: post
title:  Malware Samples - PMA Chapter 7
categories: malware
comments: true
excerpt: "Windows Operating System Features" 
---
<p>
This chapter covers some features of the Windows OS that are commonly exploited by malware such as the NT Namespace, registry, services, mutexes, Windows/Native APIs, and Microsoft's Component Object Model (COM).
</p>

<h2>Samples:</h2>
<ol>
<a href="#sample-1"><li>Malware Sample 1</li></a>
<a href="#sample-2"><li>Malware Sample 2</li></a>
<a href="#sample-3"><li>Malware Sample 3</li></a>
</ol>

<div id="sample-1" class="section-link">
<h2>Malware Sample 1</h2>
<p>
This sample uses some of the features discussed in the reading, such as mutexes, services, and threads.
</p>
</div>

<h2>Questions:</h2>
<ol>
<a href="#1-1"><li>How does this program ensure that it continues running (achieves persistence) when the computer is restarted?</li></a>
<a href="#1-2"><li>Why does this program use a mutex?</li></a>
<a href="#1-3"><li>What is a good host-based signature to use for detecting this program?</li></a>
<a href="#1-4"><li>What is a good network-based signature for detecting this malware?</li></a>
<a href="#1-5"><li>What is the purpose of this program?</li></a>
<a href="#1-6"><li>When will this program finish executing?</li></a>
</ol>

<div id="1-1" class="section-link">
<h2>How does this program ensure that it continues running (achieves persistence) when the computer is restarted?</h2>
<p>
There are no imports related to the registry, but the <b>CreateServiceA</b> function is imported from advapi32.dll. Checking the cross-references to this function shows it called in only one location, where a service is created named <b>Malservice</b> for persistence:<br>
<img src="/images/lab7/malservice.png">
</p>
</div>

<div id="1-2" class="section-link">
<h2>Why does this program use a mutex?</h2>
<p>
<b>OpenMutexA</b> was only called in one location where a mutex was created with the name <b>HGL345</b>. The purpose of a mutex, or mutual exclusion, is to ensure that there is only one instance of a process running at a time during certain actions to prevent race conditions. In this sample, the mutex is checked at the beginning of the program to prevent more than one <b>Malservice</b> running. Here, the result of <b>OpenMutexA</b> is tested and if unsuccessful, the process exits:<br>
<img src="/images/lab7/mutex.png">
</p>
</div>

<div id="1-3" class="section-link">
<h2>What is a good host-based signature to use for detecting this program?</h2>
<p>
The mutex <b>HGL345</b> and the service <b>Malservice</b> identified in the previous question are the only host-based indicators.
</p>
</div>

<div id="1-4" class="section-link">
<h2>What is a good network-based signature for detecting this malware?</h2>
<p>
After the malicious service has been started, 0x14 (decimal 20) is moved into ESI as a loop counter. The loop creates 20 threads using the subroutine located at <b>0x401150</b>:<br>
<img src="/images/lab7/threads.png">
</p>
<p>
The subroutine opens a request to <b>http://malwareanalysisbook.com</b>, which would be the best network-based indicator:<br>
<img src="/images/lab7/dos.png">
</p>
</div>

<div id="1-5" class="section-link">
<h2>What is the purpose of this program?</h2>
<p>
The <b>InternetOpenUrlA</b> call in the subroutine is located inside of a loop with no delay and no exit from the loop, indicating that the purpose of this malware is a DDoS attack (typically as part of a botnet, although that functionality is not present in this sample):<br>
<img src="/images/lab7/loop.png">
</p>
</div>

<div id="1-6" class="section-link">
<h2>When will this program finish executing?</h2>
<p>
Before the <b>CreateThread</b> loop is started, a timer is set with 0x834 as the year and <b>WaitForSingleObject</b> is called on that timer, meaning that the loop will begin starting in the year 2100:<br>
<img src="/images/lab7/timer.png"><br>
This means that the main function will begin executing in that year. Because there is no way to exit the loop, it will run endlessly unless the program is terminated.
</p>
</div>

<div id="sample-2" class="section-link">
<h2>Malware Sample 2</h2>
<p>
The main function of this sample uses a COM object to utilize existing code, which can confuse analysis.
</p>
</div>

<h2>Questions:</h2>
<ol>
<a href="#2-1"><li>How does this program achieve persistence?</li></a>
<a href="#2-2"><li>What is the purpose of this program?</li></a>
<a href="#2-3"><li>When will this program finish executing?</li></a>
</ol>

<div id="2-1" class="section-link">
<h2>How does this program achieve persistence?</h2>
<p>
There are no attempts by this program to achieve persistence.
</p>
</div>

<div id="2-2" class="section-link">
<h2>What is the purpose of this program?</h2>
<p>
This program implements Microsoft's Component Object Model (COM) for its main functionality. The use of COM complicates analysis because it re-uses code from other programs which are identified by Interface ID (IID) and Class ID (CLSID) numbers that are not easily recognizable. Here, a COM instance is created with <b>CoCreateInstance</b> using some existing code:<br>
<img src="/images/lab7/com.png"><br>
In this call, the IID and CLSID are taken from the <b>riid</b> and <b>rclsid</b> variables in the .rdata section. <b>CoCreateInstance</b> returns a pointer to the created COM object which is stored in the local variable <b>ppv</b> that was pushed as the final argument to the call.
</p>
<p>
IIDs are stored in the registry under the <b>HKEY_CLASSES_ROOT\Interface</b> key. The subkey matching the value of the <b>riid</b> variable in the .rdata section shows that this is the <b>IWebBrowser2</b> interface:<br>
<img src="/images/lab7/iid.png">
</p>
<p>
CLSIDs are also stored in the registry, but these are located within the <b>HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID</b> key. Matching the <b>rclsid</b> value from IDA shows that the code being used comes from Internet Explorer:<br>
<img src="/images/lab7/clsid.png">
</p>
<p>
It is interesting to note the leading zeroes in the sub-keys, which added some time to the search for these values. Noting the number of bytes specified in the variable helps to identify how many leading zeroes will be present. For example, the first segment of <b>rclsid</b> is <b>02 DF 01</b>, which is 3 bytes. Making it the complete 4 bytes changes that to <b>00 02 DF 01</b>, or <b>0002DF01</b>:<br>
<img src="/images/lab7/bytes.png"><br>
The same can be done for <b>riid</b>. Converting to 4 bytes drops the leading zero present in IDA.
</p>
<p>
Finally, at 0x401074 a call is made to EDX with an offset of 0x2c. Tracing back through the disassembly, EDX was last defined as [EAX]. The most recent value moved into EAX is the <b>ppv</b> variable, which holds the pointer to the <b>IWebBrowser2</b> interface instance created earlier:<br> 
<img src="/images/lab7/ppv.png">
</p>
<p>
Finding the function associated with this offset can be done automatically with IDA's <b>Add Standard Structure</b> feature, but I wanted to see exactly how this works. The IWebBrowser2 interface is defined in the exdisp.h header file as part of the Windows SDK. The vtable for the interface is easily found by appending "vtbl" to the interface name:<br>
<img src="/images/lab7/iwebbrowser2.png">
</p>
<p>
The offset for the call was 0x2c, or 44 in decimal. Each function in the vtable is 4 bytes and dividing by four means that the function is located at index 11. Starting at 0, function 11 is <b>Navigate</b>:<br>
<img src="/images/lab7/navigate.png">
</p>
<p>
Six parameters are pushed to the stack prior to the <b>Navigate</b> call. Only the first two are relevant to this analysis, which are the <b>ppv</b> pointer and the string <b>http://malwareanalysisbook.com/ad.html</b>. Shortly after this call the program exits, meaning the purpose of this program is only to navigate to the specified URL with Internet Explorer.
</p>
</div>

<div id="2-3" class="section-link">
<h2>When will this program finish executing?</h2>
<p>
Execution will finish after attempting navigation to <b>http://malwareanalysisbook.com/ad.html</b>. The success of this attempt is not checked, so the program will exit whether it is successful or not:<br>
<img src="/images/lab7/exit.png">
</p>
</div>

<div id="sample-3" class="section-link">
<h2>Malware Sample 3</h2>
<p>
This sample establishes persistence in a novel way that was difficult to analyze.
</p>
</div>

<h2>Questions:</h2>
<ol>
<a href="#3-1"><li>How does this program achieve persistence to ensure that it continues running when the computer is restarted?</li></a>
<a href="#3-2"><li>What are two good host-based signatures for this malware?</li></a>
<a href="#3-3"><li>What is the purpose of this program?</li></a>
<a href="#3-4"><li>How could you remove this malware once it is installed?</li></a>
</ol>

<div id="3-1" class="section-link">
<h2>How does this program achieve persistence to ensure that it continues running when the computer is restarted?</h2>
<p>
There are no obvious imports that indicate any kind of persistence with this sample and a thorough analysis was required to answered this question. First, a copy of kernel32.dll is mapped to memory and its handle is moved into ESI:<br>
<img src="/images/lab7/mapview-1.png">
</p>
<p>
Next, a copy of the malicious Lab07-03.dll is mapped to memory and its handle is moved into EBP:<br>
<img src="/images/lab7/mapview-2.png">
</p>
<p>
After these files are mapped to memory, there are a lot of instructions and subroutines shifting and moving values with no clear purpose (my best guess without diving too deep is that the contents of the legitimate DLL are being copied into the malicious one):<br>
<img src="/images/lab7/nonsense.png">
</p>
<p>
Reverse-engineering all off the shift and move instructions would be very time-consuming, so I skimmed through the code until I reached something relevant. After all of that noise, <b>Lab07-03.dll</b> is copied to <b>C:\windows\system32\kerne132.dll</b>, intended to be a kernel32.dll lookalike with a one instead of a lowercase L like the one from an earlier lab:<br>
<img src="/images/lab7/kerne132.png">
</p>
<p>
After the malicious DLL is copied, the string <b>C:\*</b> is pushed to the stack and the function that establishes persistence is finally called:<br>
<img src="/images/lab7/function.png">
</p>
<p>
This is a recursive function that traverses all directories in the C:\ filesystem. There is a lot of noise in this function as well, but its main purpose is finding <b>.exe</b> files. When an executable is found, another subroutine is called:<br>
<img src="/images/lab7/stricmp-1.png">
</p>
<p>
Before this function, the executable's filename is pushed to the stack and the first instructions map a view of it to memory:<br>
<img src="/images/lab7/mapview-3.png">
</p>
<p>
Next, a loop is entered that appears to iterate over the entire mapped view of the file in memory. Each time a comparison is performed against the string <b>kernel32.dll</b>:<br>
<img src="/images/lab7/stricmp-2.png">
</p>
<p>
If the comparison is unsuccessful, EDI is incremented and the loop continues. If a match is found, the essential part of this program is performed by the instruction <b>rep movsd</b>. This instruction uses ESI (Source Index) and EDI (Destination Index) as its parameters and ECX as a counter. The purpose of this instruction is just to copy ESI into EDI. Just before this call, EBX was moved into EDI. EBX last held a pointer to the bytes that were compared against the <b>kernel32.dll</b> string, meaning this is a region of the program mapped into memory holding that value:<br>
<img src="/images/lab7/edi.png">
</p>
<p>
ESI was last defined by a variable from the .data section, which is in hex form:<br>
<img src="/images/lab7/string-1.png">
</p>
<p>
Jumping to the location of that data and switching to IDA's hex view reveals the string to be copied:<br>
<img src="/images/lab7/string-2.png">
</p>
<p>
Putting all of this together, this program checks every part of every executable in the filesystem for the string <b>kernel32.dll</b> and replaces it with <b>kerne132.dll</b>, which was the malicious DLL copied into <b>C:\Windows\System32</b> earlier. This means any program that imports functions from kernel32.dll will import them from the malicious file instead. This is a clever way to achieve persistence that could be easily overlooked. 
</p>
</div>

<div id="3-2" class="section-link">
<h2>What are two good host-based signatures for this malware?</h2>
<p>
The malicious file <b>kerne132.dll</b> would be the best host-based indicator. The malicious DLL also creates a mutex named <b>SADFHUHF</b>:<br>
<img src="/images/lab7/sadfhuhf.png">
</p>
</div>

<div id="3-3" class="section-link">
<h2>What is the purpose of this program?</h2>
<p>
The purpose of the EXE file is only to establish persistence by forcing all of the host executables to import the malicious DLL. The DLL first sends the message <b>hello</b> to <b>127.26.152.13</b>:<br>
<img src="/images/lab7/hello.png">
</p>
<p>
Next, it listens for a command that would be either <b>sleep</b> or <b>exec</b>:<br>
<img src="/images/lab7/sleepexec.png">
</p>
<p>
The <b>sleep</b> command sleeps for 96 seconds and loops back to sending the <b>hello</b> string and waiting for a response. The <b>exec</b> command creates a new process using the variable IDA has defined as <b>CommandLine</b> before also looping back:<br>
<img src="/images/lab7/exec.png">
</p>
<p>
Trying to figure out where <b>CommandLine</b> was last written to could not be easily determined just by looking at the assembly. Looking at IDA's stack view shows it 5 bytes below the <b>buf</b> value written to when the C2 command was received, placing it immediately after "exec ":<br>
<img src="/images/lab7/stackview.png"><br>
This means that the purpose of the DLL is to create a process specified after the <b>exec</b> command sent from the C2 server.
</p>
</div>

<div id="3-4" class="section-link">
<h2>How could you remove this malware once it is installed?</h2>
<p>
The easiest and most reliable way to get rid of this malware is to restore Windows from a recent backup. If that is not an option, a script could be written that would undo the changes made and the malicious files would also need to be removed. Every executable on the system that references kerne132.dll would need to be re-written to use kernel32.dll again. Checking the lab solutions, the authors also sugget renaming kernel32.dll to take the place of the malicious DLL as a solution, but this would complicate any new software installs and may have other unforeseen consequences. 
</p>
</div>
<br>
<br>
<div>
<h2>Conclusion</h2>
<p>
The first and third labs in this chapter demonstrated two different ways malware can establish persistence. The first was a fairly straightforward method that created a malicious service, however analyzing the third was much more involved! The second sample demonstrated how COM objects can be used to disguise malicious functionality and taught me a lot more about Windows internals. These labs pushed my analysis skills to the limit! I am also beginning to understand the preference many analysts have for IDA over Ghidra.
</p>
</div>